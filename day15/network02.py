#클라이언트 사이드 

from socket import * 

clientSock = socket(AF_INET,SOCK_STREAM)#앞이랑 같음 #클라이언트 소캣에 대입, 소캣을 
#서버랑 연결해줘... 
#clientSock.connect(('127.0.0.1',5000)) #유프백 어드레스 실제 프로그램에서 램카드 
clientSock.connect(('192.168.0.31',5000)) #클라이어트소캣으로 '192.168.0.31',5000으로 접속함. 
#까지 메아리처럼 돌아오는 주소 
#clientSock.send("Hello~~~~~~".encode("utf-8")) #클라이언트는 연결만 해도 끝남
import random #random을 가지고 옴 
a = ['누구세요?','어서오세요','안녕하세요','기다리세요','안녕히가세요','오늘은 8월 4일입니다','똑똑','파이썬','고고고','서버 메세지입니다']
clientSock.send(random.choice(a).encode("utf-8")) #클라이언트 소켓으로 메세지를 램덤하게 보냄. encode로 받음, utf-8로 변환해서  

#루프백 어드레스 : 렘까지 갔다가 돌아오는 주소 
#포트스캔 : 어떤 것이 열려있는지 닫혀있는지 볼 수 있음. 
#해킹에 들어감 

print("연결 성공!!!") #네트워크 불안정하게 연결되어있음.

#기본적으로 다시 호출하도록 되어있음. 
#네트워크 할 때 멈추는 이유가 대기하느라고 


#ip적고 서버가 대기하고 있고 클라이언트가 하면 됨 
#서버가 허락하는 것만 가능 
#서버가 허락하지 않고 하면 해킹 

#192.168.0.31,61467은 포트 #클라이언트가 누군지 알 수 있음. 
#서버가 포트를 열어서 기다리는 문, 그번호를 바이딩 포트 번호 
#실제로 데이터 받는 포트는 다른 포트를 줌, 자꾸 오면 출입구 작아지니까
#5000포트는 서로 통신포트번호 따로 열어서 개설해줌. 
#with하고 close하면 실행파일 
#서버는 클라이언트 기록을 남김. 
#로그기록>>>텍스트파일로 만들수 있음. 
data = clientSock.recv(1024)
import random

print("서버가 보낸데이터 :" +data.decode("utf-8"))#decode(utf-8)은 우리가 읽은 수 있는
print("연결 성공!!!") 



