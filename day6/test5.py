#객체 : mutable(잘바뀌는객체), immutable(잘 안 바뀌는 객체) 
#immutable : bool, int, float, tuple, str 
#mutable : lit, set, dict 

a = 100 # a 변수 100이라는 값을 대입 
b = 100 # b 변수 a 변수의 값을 대입 

print(type(a), type(b))
a = a + 1
print(id(a), id(b)) #a라는 변수가 가리키는 값의 주소 
# #1560784...이 주소값임. 껐다 킬 때마다 다름. 
# #파이션은 주소를 저장하고 있음 reference라고 하는데, reference값을  가짐
print("----------------------------------------------------")
m = [1, 2, 3] #참조 값 

n = m  #같은 대상 주소 가짐 

print(id(m), id(n))


print(n[0])  #값쓰면 1나옴. 

n[0] = 100

# print("n[0] :", n[0],"m[0]: ", m[0]) 이렇게 하면 값 같음 
# print("id(n)",id(n), "id(m):", id(m)) 참조값 같음 
k = m[:]
print(id(m), id(k)) #다른 값으로 살림차림 슬라이싱하면 
print("k[0] :", k[0],"m[0]: ", m[0]) #값은 같은 
print("id(k)",id(k), "id(m):", id(m)) #그러나 주소는 다름. 
print("---------------------------------------------")
#k는 다른 값이어서 id다름 
# #참조값이 같음 

# print(n[0]) #n의 0번째 값은 얼마? 

# k = m[:] #슬라이싱 처음부터 끝까지 다 잘라. 

print(id(m), id(k)) 
 #기존의 값과 다르게 새로운 주소로 다른 객체를 만드는 것을 볼 수 있음
# k[0] = 100    #메모리 적게 하려고 값이 다르게 나옴. 

# print(m) #을 출력하면 서로 다른 애이기 때문에 출력값 다름



# print("-----------------------------------------")






# print(m[0])
# print(n[0])
# n[0] = 500
# print(m[0])
# print(n[0]) #같이 500이 됨. 왜? 
# #전제는 어떻게하면 메모리 
# #같은 같 가지는 애 같은 참조가지게 됨. 
# #같은 참조 가지는 애는 같이 변경이 됨
# #이렇게 하면 문제가 생길 수 있음. 
# #가리키는 곳이 같은 곳이어서 원래 a를 바꿨는데 a,b다 바뀜. 
# #같이 참조값 쓰는 애는 a를 수정하면 같이 변경 
# #엉망이 될 가능성이 있음 --- > 따로 쓰면 되요. 
# #이런 일이 없게끔 해야함. 따로 만들어서 만들면 기존의 값이 
# #엉키는 일은 없게 됨. 


#새로 만들어 새로 주는 것 참조값 바뀌는 것을 볼 수 있음 





c = [10,20,30 ]
d = c[:]
print(id(c), id(d))

print(id(c),id(d))
print(c==d)   #c는 d야? (같은 참조값으로 비교) 

print(c is d) #c는 d야?(내용이 같아?)
print("------------------------------------------------")
#리스트에 또 리스트를 넣으면??? 

#ijklmn 변수 많이 씀 -----옛날에 이것만 정수할 수 있어. 언어있음
#이렇게 쓰는 관습 배워서 이렇게 많이 씀. 

q = [[1,2],[3,4]] #  1 2 
                  # 3 4 
p = q 
#타입과 id 

print(id(q), id(p))#다른 값을 같게 됨
print(id(q[0]), id(p[0]))  #내부의 객체는 같은 주소  #실제 대상 하나 놓고 각자 저장하면 
#낭비가 됨, 두 개를 가지면 공간 차지, 똑같으면 한개만 갖고 작은 주소정도만 가지고도 
#적은 메모리 가지고 다른 것 
#복사해서 너 따로 나 따로 갖자 가능. 
#또 다른 리스트도 주소 가짐. 
#같은 리스트면 같은 주소를 또 갖고 있음 
#다르게 하고 싶으면 슬라이스 써서 
p = q[:] #값같아도 참조하는 대상 달라 
print(type(q))


p[0][0] = 5
print(p[0][0], q[0][0])
print(id(q), id(p))
print(id(q))


# 주소만 복사하는 것을 얕은 복사 --- shallow copy
# 안에 있는 주소까지 바꾸는 것 ---deep copy 

import copy #모듈 쉽게 해주는 함수 

s =[[1,2], [3,4]]
t = copy.deepcopy(s)   #함수 , copy는 모듈, 뒤의 것은 함수 s인자로 전달 
#그러면 t가 만들어짐 


print("id(s): ", id(s), "id(t) : ", id(t))
print(id(s[0]) , id(s[0]), "id(t[0] :", id(t))
"id(t[0]): ", id(t[0])


s[0][0] = 300 
print("s[0][0] : ", s[0][0], "t[0][0] : ", t[0][0])
print("id(s) :", id(s), "id(t) : ", id(t))
print("id(s[0]): ", id(s[0]),
"id(t[0]: " , id(t[0]))
#자손의 안쪽의 안쪽까지 